{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/CleanCode",
    "result": {"pageContext":{"currentCategory":"CleanCode","categories":["All","CleanCode","나의생각","TDD","JUnit","오늘의기록","SpringBoot","SpringMVC","블로그"],"edges":[{"node":{"id":"fcb333a2-a4f1-5de5-a3e1-d4e32a67255b","excerpt":"Chapter 8 - 단위 테스트 01. 테스트 코드의 중요성 테스트 코드는 실수를 바로잡아준다. 테스트 코드는 반드시 존재해야하며, 실제 코드 못지않게 중요하다. 테스트 케이스는 변경이 쉽도록 한다. 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위테스트다. 테스트 케이스가 있으면 변경이 두렵지않다. 테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 테스트 커버리지가 높을수록 버드게 대한 콩보가 줄어든다. 지저분한 테스트 코드는 테스트를 안하니만 못하다. <Effective Unit Test> 테스트의 중요성 테스트는 실사용에 적합한 설계를 끌어내준다. \n테스트를 작성해서 얻게 되는 가장 큰 수확은 테스트 자체가 아니다. 작성 과정에서 얻는 깨달음이다. 테스트는 자동화되어야 한다. 02. 테스트의 종류 Test Pyramid Unit Test: 프로그램 내부의 개별 컴포넌트의 동작을 테스트한다. 배포하기 전에 자동으로 실행되도록 많이 사용한다. Integra…","fields":{"slug":"/CleanCode-8/"},"frontmatter":{"categories":"CleanCode","title":"제로베이스-한달한권 클린코드(Chapter.9)","date":"January 15, 2022"}},"next":{"fields":{"slug":"/CleanCode-7/"}},"previous":null},{"node":{"id":"30ed3f42-c8d8-5bd5-9e2f-5e3a1ec41c0e","excerpt":"Chapter 8 - 경계 01. 경계란 - 우리코드와 외부코드 사이 오픈소스, 라이브러리를 안쓰는 프로젝트는 없다. 우리가 만든 코드에 외부에서 들어온 코드를 병합해야 한다. 외부 코드는 외부에서 만든 코드인데, 외부 시스템과 호출하거나 단순히 외부에서 만들어진 코드일 수 있다. 우리 코드와 외부 코드를 깔끔하게 통합시키기 위해 경계를 잘 지어야한다. 02. 경계 짓기 (1) 우리 코드를 보호하기 캡슐화(Encapsulation) 객체의 실제 구현을 외부로 부터 감추는 방식 Sensor라는 값을 관리해야 하는 상황(Sensor는 외부에서 사용된다.) Sensor Id와 Sensor 객체로 저장하고 싶어서, Map을 사용한다. 하지만 Map을 그대로 사용하면 Map이 가진 clear() 및 다른 불필요한 메서드가 외부로 노출되어서 누군가 사용 할 수 있다. Sensor의 ‘외부’코드의 관점에서 Sensor 객체의 값들만 가져오도록 하기 위해서 캡슐화를 진행한다. 위처럼 Map을 직…","fields":{"slug":"/CleanCode-7/"},"frontmatter":{"categories":"CleanCode","title":"제로베이스-한달한권 클린코드(Chapter.8)","date":"January 13, 2022"}},"next":{"fields":{"slug":"/CleanCode-6/"}},"previous":{"fields":{"slug":"/CleanCode-8/"}}},{"node":{"id":"b498d50d-ea05-5230-b222-fc119531a535","excerpt":"Chapter 7 - 오류 처리 01. 예외 처리 방식 오류 코드를 리턴하지 말고, 예외를 던져라 옛날에는 오류를 나타낼 때 에러코드를 던졌다. 하지만 예외를 던지는 것이 명확하고, 처리 흐름이 깔끔해진다. 오류가 발생한 부분에서 예외를 던진다. (별도의 처리가 필요한 예외라면 checked Exception으로 던진다.) checked exception에 대한 예외처리를 하지 않는다면 메서드 선언부에 throws를 명시해야 한다. 예외를 처리할 수 있는 곳에서 catch하여 처리한다. 02. Unchecked Exception을 사용하라 Checked vs Unchecked Exeption Exception을 상속하면 Checked Exeption 명시적인 예외처리가 필요하다 (예) IOException, SQLException RuntimeException을 상속하면 Unchecked Exeption 명시적인 예외처리가 필요하지 않다. (예) NullPointException,…","fields":{"slug":"/CleanCode-6/"},"frontmatter":{"categories":"CleanCode","title":"제로베이스-한달한권 클린코드(Chapter.7)","date":"January 12, 2022"}},"next":{"fields":{"slug":"/CleanCode-5/"}},"previous":{"fields":{"slug":"/CleanCode-7/"}}},{"node":{"id":"b0544ef1-5214-547b-8665-8bd79f55b79e","excerpt":"Chapter 6 - 객체와 자료구조로 데이터 표현하기 01. 자료구조 vs 객체 자료구조(Data Structure) 객체(Object) 데이터 그 자체 비즈니스 로직 자료를 공개한다. 자료를 숨기고, 추상화 한다.자료를 다루는 함수만 공개한다. 변수 사이에 조회 함수와 설정 함수로  변수를 다룬다고 객체가 되지 않는다.  (getter, setter) 추상 인터페이스를 제공해 사용자가 구현을 모른 채  자료의 핵심을 조작할 수 있다. 자료구조 vs 객체 예시(1) Vehicle 위와 같이 특별하게 비즈니스 로직이 들어가 있지 않고 단순히 값을 반환하는 경우에는 객체가 아니고 자료구조라고 할 수 있다. 자료구조 vs 객체 예시(2) Shape 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 자료 구조가 추가되면 함수를 고쳐야 한다. 객체지향 코드는 새로운 클래스를 추가하기 쉽다. 하지만 Shape에 함수가 추가 된다면 모든 클래스에 추가 된 함수를 모두 추가 해줘야 하는 단…","fields":{"slug":"/CleanCode-5/"},"frontmatter":{"categories":"CleanCode","title":"제로베이스-한달한권 클린코드(Chapter.6)","date":"January 09, 2022"}},"next":{"fields":{"slug":"/CleanCode-4/"}},"previous":{"fields":{"slug":"/CleanCode-6/"}}},{"node":{"id":"75c2b04b-3fe5-5877-a79b-c2911aeb94e2","excerpt":"Chapter 5 - 형식 맞추기 코드의 가독성에 필수적인 포멧팅 01. 포맷팅이 중요한 이유 위와 같이 형식이 맞춰져 있지 않은 코드를 보면 코드를 이해하기 난해한 경우가 생긴다. 위의 예제는 단순하지만 엄청 긴 문장의 매서드라면 어떨까? 가독성을 좋게 하기 위해서 포맷팅이 중요하다. 코드를 수월하게 읽어나갈 수 있다. 아마추어처럼 보이지 않는다. 포맷팅으로 인해 코드를 잘못해석해 버그를 발생할 위험을 줄인다. 02. 클린코드 포맷팅 적절한 길이 유지하는게 좋다. 200라인에서 500라인 이하로 유지하는게 좋다. 코드 길이를 200줄 정도로 제한하는 것은 반드시 지킬 엄격한 규칙은 아니지만, 일반적으로 큰 파일 보다는 작은 파일이 이해하기 쉽다. 현업에서는 대부분의 코드들도 200라인 정도를 유지한다고 한다. 코드 길이가 200라인을 넘어간다면, 클래스가 여러 개의 일을 하고 있을 수 있다. SRP(Single Responbility Principle - 단일 책임 원칙)위배 했…","fields":{"slug":"/CleanCode-4/"},"frontmatter":{"categories":"CleanCode","title":"제로베이스-한달한권 클린코드(Chapter.5)","date":"January 08, 2022"}},"next":{"fields":{"slug":"/CleanCode-3/"}},"previous":{"fields":{"slug":"/CleanCode-5/"}}},{"node":{"id":"564969c3-ebe2-5296-803f-5ef9e2525488","excerpt":"Chapter 4 - 주석 01. 주석을 최대한 쓰지 말자 주석은 나쁜 코드를 보완하지 못한다. 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다. 자신이 저지른 난장판을 주석으로 설명하지 말고 개선하는 데 시간을 보내야 한다. 코드로도 의도 표현이 가능하다! 주석은 방치된다. 코드의 변화에 따라가지 못하고, 주석은 방치된다. 코드는 컴파일되어 호출되지만, 주석은 그저 주석이기 때문에 그 자리에 방치되고 결국 의미없는 텍스트가 되어버린다. 복지 혜택에 연금 혜택 기준 기능이 추가된다면 주석은 변화에 따라가지 못한다. 02. 좋은 주석 구현에 대한 정보를 제공한다. 의도와 중요성을 설명하는 주석 TODO, FIXME 주석  TODO: 앞으로 할 일. 지금은 해결하지 않지만 나중에 해야할 일을 미리 적어둘 때. FIXME: 문제가 있찌만, 당장 수정할 필요는 없을 때. 가능하면 빨리 수정하는게 좋다.  03. 주석보다 annotation java.lang.annota…","fields":{"slug":"/CleanCode-3/"},"frontmatter":{"categories":"CleanCode","title":"제로베이스-한달한권 클린코드(Chapter.4)","date":"January 06, 2022"}},"next":{"fields":{"slug":"/CleanCode-2/"}},"previous":{"fields":{"slug":"/CleanCode-4/"}}},{"node":{"id":"4ece670f-acd3-5214-a63d-01f6b9f18d0f","excerpt":"Chapter 3 - 함수 01. SOLID 원칙 S : SRP(Single Responbility Principle) - 단일 책임 원칙 \nO : OCP(Open Close Principle) - 개방-폐쇄 원칙 \nL : LSP(Liskov’s Substitution Principle) - 리스코프 치환 원칙 \nI : ISP(Interface Segregaion Principle) - 인터페이스 분리 원칙 \nD : DIP(Dpendency Inversion Principle) - 의존성 역전 원칙 SRP (Single Responbility Principle) - 단일 책임 원칙 한 클래스는 하나의 책임만 가져야 한다. 클래스는 하나의 기능만 가지며, 어떤 변화에 의해 클래스를 변경 해야 하는 이유는 오직 하나 뿐이어야 한다. SRP 책임이 분명해지기 때문에, 변경에 의한 연쇄작용에서 자유로워질 수 있다. 가독성 향상과 유지보수가 용이해진다. 실전에서는 쉽지 않지만 늘 상기해야 …","fields":{"slug":"/CleanCode-2/"},"frontmatter":{"categories":"CleanCode","title":"제로베이스-한달한권 클린코드(Chapter.3)","date":"January 04, 2022"}},"next":{"fields":{"slug":"/CleanCode-1/"}},"previous":{"fields":{"slug":"/CleanCode-3/"}}},{"node":{"id":"119d0a0b-5239-57f0-b981-a3ad4253299f","excerpt":"- 목표 CleanCode에 대한 전반적인 지식을 쌓는다. CleanCode를 작성하기 위한 방법을 습득한다. 제로베이스 한달한권 강의를 커리큘럼을 특별한 일이 없으면 지키도록한다. - 책을 읽게 된 계기 일하면서 매일 작성하는 내 코드가 프로젝트가 종료되고 나중에 다른 사람이 내 코드를 봤을 때 이해를 잘 하고 유지보수를 잘 할 수 있을까에 대한 의문이 항상 있었다. 클린코드라는 책을 예전부터 알고 있었지만 우선순위를 계속 뒤로 미루던 상황에서 TDD를 먼저 공부하려고 하다가 현재 나에게 시급한거는 깨끗한 코드를 작성하는게 좀 더 우선시 되어야 하겠다고 생각해서 먼저 진행하던 TDD에 대한 기록은 잠시 접어두고 고민하던 중 제로베이스의 한달한권 광고를 보게되어 시작하게 되었다. 이렇게 시작하지 않으면 계속 미뤄질 것 같아서 새해를 기점으로 바로 시작한다. Chapter 1 - 깨끗한 코드 01. 나쁜 코드 성능이 나쁜 코드 불필요한 연산이 들어가서 개선의 여지가 있는 코드 의미가…","fields":{"slug":"/CleanCode-1/"},"frontmatter":{"categories":"CleanCode","title":"제로베이스-한달한권 클린코드(Chapter.1, 2)","date":"January 02, 2022"}},"next":{"fields":{"slug":"/2021-memoir/"}},"previous":{"fields":{"slug":"/CleanCode-2/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}